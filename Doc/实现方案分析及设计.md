# 对 Clang 进行二次开发

* 非功能需求  
    win平台  
    使用任意设计模式

* 功能需求  
    实现分析全局变量、调用全局变量的函数  
    实现可视化界面  
    使用该软件分析三个 1e4 行以上的开源项目并展示

---

## 分析的粒度大小？

> 全局变量的作用域为 从变量声明开始，到该文件(.h \ .cpp) 结尾为止

1. include 语句的影响

    编译流程:  
    > 宏替换、#include文本替换  
    > 生成多个实际的 .cpp 文件  
    > 每个 .cpp 文件编译为 .o 文件 —— 词法分析/语法分析/语义分析 均包含于此过程  
    > 编译器将所有 .o 文件进行链接  
    >
    include 效果:  
    >\#include 实际为文本替换
    >
    >在 main.cpp 中键入 #include "X" 语句  
    >实际效果为 在该命令位置 将文件 X 的所有内容复制一遍  
    >即 包含 #include 语句的 .cpp 文件，可以抽象理解为一个经过文本扩展的文件  
    >
    >而 .h 文件不需要单独进行编译 (因为被include过的 .h 会在相应 .cpp 文件中进行编译)  
    >不同 .cpp 文件间共享的仅有 函数 和 类 (暂不考虑 extern 关键字)  
    >对某个项目进行分析，实际上相当于对其中所有的 .cpp 文件进行单独分析 (.c 同理)
    >
    >分析基本粒度为经过文本替换处理的单个 .cpp 文件

2. 关于文本替换的分析

    在实际代码中， #include 语句通常会连接两类文件  
    一类是库文件 如
    ```cpp
    #include <cstdio>
    #include <string>
    #include <windows.h>
    ```
    另一类是用户自行编写的头文件 如
    ```cpp
    #include "parsar.h"
    #include "AST.h"
    ```
    而每个被 #include 的文件中可能会继续包含其余文件，从而形成一个包含关系的 DEG  

    由于在大部分实际项目中，用户文件很少直接调用在 .h 中声明的变量 (.h 文件中也极少直接声明变量，多为直接使用宏定义)
    
    所以在本软件实现过程中考虑采用两种模式:  
    * 包含所有头文件值的分析
    * 仅分析用户声明的头文件

    > 截至目前，问题规约为对单个 .cpp 文件进行全局变量分析

---

## 实现思路

可以简单的从 AST 中找到所有的全局变量声明
    
    遍历 AST, 维护某数据结构，其中保存了所有的全局变量和调用信息

展示方式

    首先，打开某个项目后显示所有代码文件
        仅支持打开 .cpp 、 .c 文件
    对每个文件， 初始界面类似文本编辑器， 用颜色标识每个全局变量
    点击全局变量查看该全局变量的调用位置

    左侧包含过滤器
    可以通过 数据类型、变量名 等方式查看变量

    扩展方式为 数据流分析图(有能力的话搞一个)